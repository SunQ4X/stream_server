// Code generated by protoc-gen-go. DO NOT EDIT.
// source: playback.proto

/*
Package PlaybackProtocol is a generated protocol buffer package.

It is generated from these files:
	playback.proto

It has these top-level messages:
	Channel
	OpenRequest
	OpenReply
	StreamRequest
	StreamReply
	CloseRequest
	CloseReply
	SeekRequest
	SeekReply
*/
package PlaybackProtocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Channel struct {
	Device string `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	Ch     uint32 `protobuf:"varint,2,opt,name=ch" json:"ch,omitempty"`
}

func (m *Channel) Reset()                    { *m = Channel{} }
func (m *Channel) String() string            { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()               {}
func (*Channel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Channel) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *Channel) GetCh() uint32 {
	if m != nil {
		return m.Ch
	}
	return 0
}

type OpenRequest struct {
	Channels   []*Channel `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
	BeginTime  uint64     `protobuf:"varint,2,opt,name=beginTime" json:"beginTime,omitempty"`
	EndTime    uint64     `protobuf:"varint,3,opt,name=endTime" json:"endTime,omitempty"`
	StreamType uint32     `protobuf:"varint,4,opt,name=streamType" json:"streamType,omitempty"`
	RecordType uint32     `protobuf:"varint,5,opt,name=recordType" json:"recordType,omitempty"`
	OrAnd      uint32     `protobuf:"varint,6,opt,name=orAnd" json:"orAnd,omitempty"`
}

func (m *OpenRequest) Reset()                    { *m = OpenRequest{} }
func (m *OpenRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenRequest) ProtoMessage()               {}
func (*OpenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *OpenRequest) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *OpenRequest) GetBeginTime() uint64 {
	if m != nil {
		return m.BeginTime
	}
	return 0
}

func (m *OpenRequest) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *OpenRequest) GetStreamType() uint32 {
	if m != nil {
		return m.StreamType
	}
	return 0
}

func (m *OpenRequest) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *OpenRequest) GetOrAnd() uint32 {
	if m != nil {
		return m.OrAnd
	}
	return 0
}

type OpenReply struct {
	Error  string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Handle uint64 `protobuf:"varint,2,opt,name=handle" json:"handle,omitempty"`
}

func (m *OpenReply) Reset()                    { *m = OpenReply{} }
func (m *OpenReply) String() string            { return proto.CompactTextString(m) }
func (*OpenReply) ProtoMessage()               {}
func (*OpenReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *OpenReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *OpenReply) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

type StreamRequest struct {
	Handle uint64 `protobuf:"varint,1,opt,name=handle" json:"handle,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StreamRequest) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

type StreamReply struct {
	Error     string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	DataSize  uint32 `protobuf:"varint,2,opt,name=dataSize" json:"dataSize,omitempty"`
	Data      []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	FrameTime uint64 `protobuf:"varint,4,opt,name=frameTime" json:"frameTime,omitempty"`
	Device    string `protobuf:"bytes,5,opt,name=device" json:"device,omitempty"`
	Ch        uint32 `protobuf:"varint,6,opt,name=ch" json:"ch,omitempty"`
	Pid       uint64 `protobuf:"varint,7,opt,name=pid" json:"pid,omitempty"`
	Checksum  string `protobuf:"bytes,8,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *StreamReply) Reset()                    { *m = StreamReply{} }
func (m *StreamReply) String() string            { return proto.CompactTextString(m) }
func (*StreamReply) ProtoMessage()               {}
func (*StreamReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StreamReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *StreamReply) GetDataSize() uint32 {
	if m != nil {
		return m.DataSize
	}
	return 0
}

func (m *StreamReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *StreamReply) GetFrameTime() uint64 {
	if m != nil {
		return m.FrameTime
	}
	return 0
}

func (m *StreamReply) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *StreamReply) GetCh() uint32 {
	if m != nil {
		return m.Ch
	}
	return 0
}

func (m *StreamReply) GetPid() uint64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *StreamReply) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type CloseRequest struct {
	Handle uint64 `protobuf:"varint,1,opt,name=handle" json:"handle,omitempty"`
}

func (m *CloseRequest) Reset()                    { *m = CloseRequest{} }
func (m *CloseRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseRequest) ProtoMessage()               {}
func (*CloseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CloseRequest) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

type CloseReply struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *CloseReply) Reset()                    { *m = CloseReply{} }
func (m *CloseReply) String() string            { return proto.CompactTextString(m) }
func (*CloseReply) ProtoMessage()               {}
func (*CloseReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CloseReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SeekRequest struct {
	Handle     uint64 `protobuf:"varint,1,opt,name=handle" json:"handle,omitempty"`
	SeekTime   uint64 `protobuf:"varint,2,opt,name=seekTime" json:"seekTime,omitempty"`
	StreamType uint32 `protobuf:"varint,3,opt,name=streamType" json:"streamType,omitempty"`
	RecordType uint32 `protobuf:"varint,4,opt,name=recordType" json:"recordType,omitempty"`
	OrAnd      uint32 `protobuf:"varint,5,opt,name=orAnd" json:"orAnd,omitempty"`
}

func (m *SeekRequest) Reset()                    { *m = SeekRequest{} }
func (m *SeekRequest) String() string            { return proto.CompactTextString(m) }
func (*SeekRequest) ProtoMessage()               {}
func (*SeekRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SeekRequest) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *SeekRequest) GetSeekTime() uint64 {
	if m != nil {
		return m.SeekTime
	}
	return 0
}

func (m *SeekRequest) GetStreamType() uint32 {
	if m != nil {
		return m.StreamType
	}
	return 0
}

func (m *SeekRequest) GetRecordType() uint32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *SeekRequest) GetOrAnd() uint32 {
	if m != nil {
		return m.OrAnd
	}
	return 0
}

type SeekReply struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *SeekReply) Reset()                    { *m = SeekReply{} }
func (m *SeekReply) String() string            { return proto.CompactTextString(m) }
func (*SeekReply) ProtoMessage()               {}
func (*SeekReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SeekReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*Channel)(nil), "PlaybackProtocol.Channel")
	proto.RegisterType((*OpenRequest)(nil), "PlaybackProtocol.OpenRequest")
	proto.RegisterType((*OpenReply)(nil), "PlaybackProtocol.OpenReply")
	proto.RegisterType((*StreamRequest)(nil), "PlaybackProtocol.StreamRequest")
	proto.RegisterType((*StreamReply)(nil), "PlaybackProtocol.StreamReply")
	proto.RegisterType((*CloseRequest)(nil), "PlaybackProtocol.CloseRequest")
	proto.RegisterType((*CloseReply)(nil), "PlaybackProtocol.CloseReply")
	proto.RegisterType((*SeekRequest)(nil), "PlaybackProtocol.SeekRequest")
	proto.RegisterType((*SeekReply)(nil), "PlaybackProtocol.SeekReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Playback service

type PlaybackClient interface {
	Open(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*OpenReply, error)
	Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Playback_StreamClient, error)
	Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*CloseReply, error)
	Seek(ctx context.Context, in *SeekRequest, opts ...grpc.CallOption) (*SeekReply, error)
}

type playbackClient struct {
	cc *grpc.ClientConn
}

func NewPlaybackClient(cc *grpc.ClientConn) PlaybackClient {
	return &playbackClient{cc}
}

func (c *playbackClient) Open(ctx context.Context, in *OpenRequest, opts ...grpc.CallOption) (*OpenReply, error) {
	out := new(OpenReply)
	err := grpc.Invoke(ctx, "/PlaybackProtocol.Playback/open", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playbackClient) Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Playback_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Playback_serviceDesc.Streams[0], c.cc, "/PlaybackProtocol.Playback/stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &playbackStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Playback_StreamClient interface {
	Recv() (*StreamReply, error)
	grpc.ClientStream
}

type playbackStreamClient struct {
	grpc.ClientStream
}

func (x *playbackStreamClient) Recv() (*StreamReply, error) {
	m := new(StreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *playbackClient) Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*CloseReply, error) {
	out := new(CloseReply)
	err := grpc.Invoke(ctx, "/PlaybackProtocol.Playback/close", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playbackClient) Seek(ctx context.Context, in *SeekRequest, opts ...grpc.CallOption) (*SeekReply, error) {
	out := new(SeekReply)
	err := grpc.Invoke(ctx, "/PlaybackProtocol.Playback/seek", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Playback service

type PlaybackServer interface {
	Open(context.Context, *OpenRequest) (*OpenReply, error)
	Stream(*StreamRequest, Playback_StreamServer) error
	Close(context.Context, *CloseRequest) (*CloseReply, error)
	Seek(context.Context, *SeekRequest) (*SeekReply, error)
}

func RegisterPlaybackServer(s *grpc.Server, srv PlaybackServer) {
	s.RegisterService(&_Playback_serviceDesc, srv)
}

func _Playback_Open_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaybackServer).Open(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PlaybackProtocol.Playback/Open",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaybackServer).Open(ctx, req.(*OpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Playback_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlaybackServer).Stream(m, &playbackStreamServer{stream})
}

type Playback_StreamServer interface {
	Send(*StreamReply) error
	grpc.ServerStream
}

type playbackStreamServer struct {
	grpc.ServerStream
}

func (x *playbackStreamServer) Send(m *StreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Playback_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaybackServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PlaybackProtocol.Playback/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaybackServer).Close(ctx, req.(*CloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Playback_Seek_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeekRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaybackServer).Seek(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PlaybackProtocol.Playback/Seek",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaybackServer).Seek(ctx, req.(*SeekRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Playback_serviceDesc = grpc.ServiceDesc{
	ServiceName: "PlaybackProtocol.Playback",
	HandlerType: (*PlaybackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "open",
			Handler:    _Playback_Open_Handler,
		},
		{
			MethodName: "close",
			Handler:    _Playback_Close_Handler,
		},
		{
			MethodName: "seek",
			Handler:    _Playback_Seek_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "stream",
			Handler:       _Playback_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "playback.proto",
}

func init() { proto.RegisterFile("playback.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 481 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x5d, 0xda, 0x24, 0x6d, 0x6f, 0xb7, 0x69, 0xba, 0x42, 0x28, 0x94, 0x6d, 0x14, 0x3f, 0x40,
	0x9f, 0x2a, 0x18, 0xe2, 0x81, 0x47, 0xb4, 0x49, 0xbc, 0x20, 0x31, 0x65, 0xfb, 0x81, 0xd4, 0xb9,
	0x90, 0xa8, 0xa9, 0x6d, 0x9c, 0x0e, 0xa9, 0xfc, 0x08, 0x5f, 0xc1, 0x77, 0xf0, 0xce, 0x17, 0x4d,
	0xb6, 0x93, 0x34, 0xdb, 0x1a, 0xf5, 0xcd, 0xc7, 0xf7, 0xc4, 0x3e, 0xf7, 0xdc, 0xe3, 0xc0, 0xb1,
	0x2a, 0x92, 0xcd, 0x22, 0xe1, 0xcb, 0xb9, 0xd2, 0x72, 0x2d, 0xf1, 0xe4, 0xba, 0xc2, 0xd7, 0x06,
	0x72, 0x59, 0xb0, 0xf7, 0x30, 0xb8, 0xcc, 0x12, 0x21, 0xa8, 0xc0, 0xe7, 0x10, 0xa6, 0xf4, 0x2b,
	0xe7, 0x14, 0x79, 0x53, 0x6f, 0x36, 0x8a, 0x2b, 0x84, 0xc7, 0xd0, 0xe3, 0x59, 0xd4, 0x9b, 0x7a,
	0xb3, 0xa3, 0xb8, 0xc7, 0x33, 0xf6, 0xdf, 0x83, 0xf1, 0x37, 0x45, 0x22, 0xa6, 0x9f, 0x77, 0x54,
	0xae, 0xf1, 0x23, 0x0c, 0xb9, 0x3b, 0xa2, 0x8c, 0xbc, 0x69, 0x7f, 0x36, 0xbe, 0x78, 0x31, 0x7f,
	0x7c, 0xcf, 0xbc, 0xba, 0x24, 0x6e, 0xa8, 0x78, 0x0a, 0xa3, 0x05, 0xfd, 0xc8, 0xc5, 0x6d, 0xbe,
	0x22, 0x7b, 0xba, 0x1f, 0x6f, 0x37, 0x30, 0x82, 0x01, 0x89, 0xd4, 0xd6, 0xfa, 0xb6, 0x56, 0x43,
	0x3c, 0x07, 0x28, 0xd7, 0x9a, 0x92, 0xd5, 0xed, 0x46, 0x51, 0xe4, 0x5b, 0x59, 0xad, 0x1d, 0x53,
	0xd7, 0xc4, 0xa5, 0x4e, 0x6d, 0x3d, 0x70, 0xf5, 0xed, 0x0e, 0x3e, 0x83, 0x40, 0xea, 0xcf, 0x22,
	0x8d, 0x42, 0x5b, 0x72, 0x80, 0x7d, 0x82, 0x91, 0xeb, 0x49, 0x15, 0x1b, 0x43, 0x21, 0xad, 0xa5,
	0xae, 0x8c, 0x70, 0xc0, 0xf8, 0x93, 0x25, 0x22, 0x2d, 0x6a, 0xb5, 0x15, 0x62, 0x6f, 0xe1, 0xe8,
	0xc6, 0x5e, 0x5f, 0x1b, 0xb2, 0x25, 0x7a, 0x0f, 0x88, 0xff, 0x3c, 0x18, 0xd7, 0xcc, 0xee, 0x6b,
	0x26, 0x30, 0x4c, 0x93, 0x75, 0x72, 0x93, 0xff, 0xa6, 0xca, 0xf4, 0x06, 0x23, 0x82, 0x6f, 0xd6,
	0xd6, 0x92, 0xc3, 0xd8, 0xae, 0x8d, 0x8f, 0xdf, 0x75, 0xb2, 0x22, 0xeb, 0x95, 0xef, 0x7c, 0x6c,
	0x36, 0x5a, 0x43, 0x0d, 0x76, 0x0c, 0x35, 0xac, 0x87, 0x8a, 0x27, 0xd0, 0x57, 0x79, 0x1a, 0x0d,
	0xec, 0xf7, 0x66, 0x69, 0x74, 0xf0, 0x8c, 0xf8, 0xb2, 0xbc, 0x5b, 0x45, 0x43, 0xfb, 0x6d, 0x83,
	0xd9, 0x1b, 0x38, 0xbc, 0x2c, 0x64, 0x49, 0xfb, 0x3a, 0x66, 0x00, 0x15, 0xaf, 0xb3, 0x5f, 0xf6,
	0xc7, 0xb8, 0x42, 0xb4, 0xdc, 0x73, 0x96, 0xd1, 0x53, 0x12, 0x2d, 0x5b, 0x71, 0x69, 0xf0, 0xa3,
	0x4c, 0xf4, 0xf7, 0x64, 0xc2, 0xef, 0xce, 0x44, 0xd0, 0xce, 0xc4, 0x6b, 0x18, 0x39, 0x61, 0x9d,
	0xe2, 0x2f, 0xfe, 0xf6, 0x60, 0x58, 0x67, 0x1d, 0xaf, 0xc0, 0x97, 0x8a, 0x04, 0x9e, 0x3d, 0x8d,
	0x7f, 0xeb, 0xbd, 0x4c, 0x5e, 0x76, 0x95, 0x55, 0xb1, 0x61, 0x07, 0xf8, 0x15, 0x42, 0xa7, 0x1c,
	0x5f, 0x3d, 0x25, 0x3e, 0x08, 0xda, 0xe4, 0xac, 0x9b, 0x60, 0xcf, 0x7a, 0xe7, 0xe1, 0x17, 0x08,
	0xb8, 0x99, 0x00, 0x9e, 0xef, 0x78, 0x93, 0xad, 0x11, 0x4e, 0x4e, 0x3b, 0xeb, 0x4e, 0xd6, 0x15,
	0xf8, 0xc6, 0xee, 0x5d, 0xcd, 0xb5, 0xa6, 0xb7, 0xab, 0xb9, 0xc6, 0x43, 0x76, 0xb0, 0x08, 0xed,
	0x7f, 0xe8, 0xc3, 0x7d, 0x00, 0x00, 0x00, 0xff, 0xff, 0x24, 0x4e, 0xcb, 0x6e, 0x99, 0x04, 0x00,
	0x00,
}
